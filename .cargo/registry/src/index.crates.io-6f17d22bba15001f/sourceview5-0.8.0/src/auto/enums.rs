// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files.git)
// DO NOT EDIT

use glib::{prelude::*, translate::*};

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceBackgroundPatternType")]
pub enum BackgroundPatternType {
    #[doc(alias = "GTK_SOURCE_BACKGROUND_PATTERN_TYPE_NONE")]
    None,
    #[doc(alias = "GTK_SOURCE_BACKGROUND_PATTERN_TYPE_GRID")]
    Grid,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for BackgroundPatternType {
    type GlibType = ffi::GtkSourceBackgroundPatternType;

    #[inline]
    fn into_glib(self) -> ffi::GtkSourceBackgroundPatternType {
        match self {
            Self::None => ffi::GTK_SOURCE_BACKGROUND_PATTERN_TYPE_NONE,
            Self::Grid => ffi::GTK_SOURCE_BACKGROUND_PATTERN_TYPE_GRID,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceBackgroundPatternType> for BackgroundPatternType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSourceBackgroundPatternType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SOURCE_BACKGROUND_PATTERN_TYPE_NONE => Self::None,
            ffi::GTK_SOURCE_BACKGROUND_PATTERN_TYPE_GRID => Self::Grid,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for BackgroundPatternType {
    #[inline]
    #[doc(alias = "gtk_source_background_pattern_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_source_background_pattern_type_get_type()) }
    }
}

impl glib::HasParamSpec for BackgroundPatternType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for BackgroundPatternType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for BackgroundPatternType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for BackgroundPatternType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<BackgroundPatternType> for glib::Value {
    #[inline]
    fn from(v: BackgroundPatternType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceBracketMatchType")]
pub enum BracketMatchType {
    #[doc(alias = "GTK_SOURCE_BRACKET_MATCH_NONE")]
    None,
    #[doc(alias = "GTK_SOURCE_BRACKET_MATCH_OUT_OF_RANGE")]
    OutOfRange,
    #[doc(alias = "GTK_SOURCE_BRACKET_MATCH_NOT_FOUND")]
    NotFound,
    #[doc(alias = "GTK_SOURCE_BRACKET_MATCH_FOUND")]
    Found,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for BracketMatchType {
    type GlibType = ffi::GtkSourceBracketMatchType;

    #[inline]
    fn into_glib(self) -> ffi::GtkSourceBracketMatchType {
        match self {
            Self::None => ffi::GTK_SOURCE_BRACKET_MATCH_NONE,
            Self::OutOfRange => ffi::GTK_SOURCE_BRACKET_MATCH_OUT_OF_RANGE,
            Self::NotFound => ffi::GTK_SOURCE_BRACKET_MATCH_NOT_FOUND,
            Self::Found => ffi::GTK_SOURCE_BRACKET_MATCH_FOUND,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceBracketMatchType> for BracketMatchType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSourceBracketMatchType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SOURCE_BRACKET_MATCH_NONE => Self::None,
            ffi::GTK_SOURCE_BRACKET_MATCH_OUT_OF_RANGE => Self::OutOfRange,
            ffi::GTK_SOURCE_BRACKET_MATCH_NOT_FOUND => Self::NotFound,
            ffi::GTK_SOURCE_BRACKET_MATCH_FOUND => Self::Found,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for BracketMatchType {
    #[inline]
    #[doc(alias = "gtk_source_bracket_match_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_source_bracket_match_type_get_type()) }
    }
}

impl glib::HasParamSpec for BracketMatchType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for BracketMatchType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for BracketMatchType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for BracketMatchType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<BracketMatchType> for glib::Value {
    #[inline]
    fn from(v: BracketMatchType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceChangeCaseType")]
pub enum ChangeCaseType {
    #[doc(alias = "GTK_SOURCE_CHANGE_CASE_LOWER")]
    Lower,
    #[doc(alias = "GTK_SOURCE_CHANGE_CASE_UPPER")]
    Upper,
    #[doc(alias = "GTK_SOURCE_CHANGE_CASE_TOGGLE")]
    Toggle,
    #[doc(alias = "GTK_SOURCE_CHANGE_CASE_TITLE")]
    Title,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ChangeCaseType {
    type GlibType = ffi::GtkSourceChangeCaseType;

    #[inline]
    fn into_glib(self) -> ffi::GtkSourceChangeCaseType {
        match self {
            Self::Lower => ffi::GTK_SOURCE_CHANGE_CASE_LOWER,
            Self::Upper => ffi::GTK_SOURCE_CHANGE_CASE_UPPER,
            Self::Toggle => ffi::GTK_SOURCE_CHANGE_CASE_TOGGLE,
            Self::Title => ffi::GTK_SOURCE_CHANGE_CASE_TITLE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceChangeCaseType> for ChangeCaseType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSourceChangeCaseType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SOURCE_CHANGE_CASE_LOWER => Self::Lower,
            ffi::GTK_SOURCE_CHANGE_CASE_UPPER => Self::Upper,
            ffi::GTK_SOURCE_CHANGE_CASE_TOGGLE => Self::Toggle,
            ffi::GTK_SOURCE_CHANGE_CASE_TITLE => Self::Title,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ChangeCaseType {
    #[inline]
    #[doc(alias = "gtk_source_change_case_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_source_change_case_type_get_type()) }
    }
}

impl glib::HasParamSpec for ChangeCaseType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ChangeCaseType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ChangeCaseType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ChangeCaseType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ChangeCaseType> for glib::Value {
    #[inline]
    fn from(v: ChangeCaseType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceCompletionActivation")]
pub enum CompletionActivation {
    #[doc(alias = "GTK_SOURCE_COMPLETION_ACTIVATION_NONE")]
    None,
    #[doc(alias = "GTK_SOURCE_COMPLETION_ACTIVATION_INTERACTIVE")]
    Interactive,
    #[doc(alias = "GTK_SOURCE_COMPLETION_ACTIVATION_USER_REQUESTED")]
    UserRequested,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CompletionActivation {
    type GlibType = ffi::GtkSourceCompletionActivation;

    #[inline]
    fn into_glib(self) -> ffi::GtkSourceCompletionActivation {
        match self {
            Self::None => ffi::GTK_SOURCE_COMPLETION_ACTIVATION_NONE,
            Self::Interactive => ffi::GTK_SOURCE_COMPLETION_ACTIVATION_INTERACTIVE,
            Self::UserRequested => ffi::GTK_SOURCE_COMPLETION_ACTIVATION_USER_REQUESTED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceCompletionActivation> for CompletionActivation {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSourceCompletionActivation) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SOURCE_COMPLETION_ACTIVATION_NONE => Self::None,
            ffi::GTK_SOURCE_COMPLETION_ACTIVATION_INTERACTIVE => Self::Interactive,
            ffi::GTK_SOURCE_COMPLETION_ACTIVATION_USER_REQUESTED => Self::UserRequested,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CompletionActivation {
    #[inline]
    #[doc(alias = "gtk_source_completion_activation_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_source_completion_activation_get_type()) }
    }
}

impl glib::HasParamSpec for CompletionActivation {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for CompletionActivation {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CompletionActivation {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CompletionActivation {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CompletionActivation> for glib::Value {
    #[inline]
    fn from(v: CompletionActivation) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceCompletionColumn")]
pub enum CompletionColumn {
    #[doc(alias = "GTK_SOURCE_COMPLETION_COLUMN_ICON")]
    Icon,
    #[doc(alias = "GTK_SOURCE_COMPLETION_COLUMN_BEFORE")]
    Before,
    #[doc(alias = "GTK_SOURCE_COMPLETION_COLUMN_TYPED_TEXT")]
    TypedText,
    #[doc(alias = "GTK_SOURCE_COMPLETION_COLUMN_AFTER")]
    After,
    #[doc(alias = "GTK_SOURCE_COMPLETION_COLUMN_COMMENT")]
    Comment,
    #[doc(alias = "GTK_SOURCE_COMPLETION_COLUMN_DETAILS")]
    Details,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CompletionColumn {
    type GlibType = ffi::GtkSourceCompletionColumn;

    #[inline]
    fn into_glib(self) -> ffi::GtkSourceCompletionColumn {
        match self {
            Self::Icon => ffi::GTK_SOURCE_COMPLETION_COLUMN_ICON,
            Self::Before => ffi::GTK_SOURCE_COMPLETION_COLUMN_BEFORE,
            Self::TypedText => ffi::GTK_SOURCE_COMPLETION_COLUMN_TYPED_TEXT,
            Self::After => ffi::GTK_SOURCE_COMPLETION_COLUMN_AFTER,
            Self::Comment => ffi::GTK_SOURCE_COMPLETION_COLUMN_COMMENT,
            Self::Details => ffi::GTK_SOURCE_COMPLETION_COLUMN_DETAILS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceCompletionColumn> for CompletionColumn {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSourceCompletionColumn) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SOURCE_COMPLETION_COLUMN_ICON => Self::Icon,
            ffi::GTK_SOURCE_COMPLETION_COLUMN_BEFORE => Self::Before,
            ffi::GTK_SOURCE_COMPLETION_COLUMN_TYPED_TEXT => Self::TypedText,
            ffi::GTK_SOURCE_COMPLETION_COLUMN_AFTER => Self::After,
            ffi::GTK_SOURCE_COMPLETION_COLUMN_COMMENT => Self::Comment,
            ffi::GTK_SOURCE_COMPLETION_COLUMN_DETAILS => Self::Details,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CompletionColumn {
    #[inline]
    #[doc(alias = "gtk_source_completion_column_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_source_completion_column_get_type()) }
    }
}

impl glib::HasParamSpec for CompletionColumn {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for CompletionColumn {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CompletionColumn {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CompletionColumn {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CompletionColumn> for glib::Value {
    #[inline]
    fn from(v: CompletionColumn) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceCompressionType")]
pub enum CompressionType {
    #[doc(alias = "GTK_SOURCE_COMPRESSION_TYPE_NONE")]
    None,
    #[doc(alias = "GTK_SOURCE_COMPRESSION_TYPE_GZIP")]
    Gzip,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CompressionType {
    type GlibType = ffi::GtkSourceCompressionType;

    #[inline]
    fn into_glib(self) -> ffi::GtkSourceCompressionType {
        match self {
            Self::None => ffi::GTK_SOURCE_COMPRESSION_TYPE_NONE,
            Self::Gzip => ffi::GTK_SOURCE_COMPRESSION_TYPE_GZIP,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceCompressionType> for CompressionType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSourceCompressionType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SOURCE_COMPRESSION_TYPE_NONE => Self::None,
            ffi::GTK_SOURCE_COMPRESSION_TYPE_GZIP => Self::Gzip,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CompressionType {
    #[inline]
    #[doc(alias = "gtk_source_compression_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_source_compression_type_get_type()) }
    }
}

impl glib::HasParamSpec for CompressionType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for CompressionType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CompressionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CompressionType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CompressionType> for glib::Value {
    #[inline]
    fn from(v: CompressionType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceFileLoaderError")]
pub enum FileLoaderError {
    #[doc(alias = "GTK_SOURCE_FILE_LOADER_ERROR_TOO_BIG")]
    TooBig,
    #[doc(alias = "GTK_SOURCE_FILE_LOADER_ERROR_ENCODING_AUTO_DETECTION_FAILED")]
    EncodingAutoDetectionFailed,
    #[doc(alias = "GTK_SOURCE_FILE_LOADER_ERROR_CONVERSION_FALLBACK")]
    ConversionFallback,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for FileLoaderError {
    type GlibType = ffi::GtkSourceFileLoaderError;

    #[inline]
    fn into_glib(self) -> ffi::GtkSourceFileLoaderError {
        match self {
            Self::TooBig => ffi::GTK_SOURCE_FILE_LOADER_ERROR_TOO_BIG,
            Self::EncodingAutoDetectionFailed => {
                ffi::GTK_SOURCE_FILE_LOADER_ERROR_ENCODING_AUTO_DETECTION_FAILED
            }
            Self::ConversionFallback => ffi::GTK_SOURCE_FILE_LOADER_ERROR_CONVERSION_FALLBACK,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceFileLoaderError> for FileLoaderError {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSourceFileLoaderError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SOURCE_FILE_LOADER_ERROR_TOO_BIG => Self::TooBig,
            ffi::GTK_SOURCE_FILE_LOADER_ERROR_ENCODING_AUTO_DETECTION_FAILED => {
                Self::EncodingAutoDetectionFailed
            }
            ffi::GTK_SOURCE_FILE_LOADER_ERROR_CONVERSION_FALLBACK => Self::ConversionFallback,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for FileLoaderError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_source_file_loader_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

impl StaticType for FileLoaderError {
    #[inline]
    #[doc(alias = "gtk_source_file_loader_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_source_file_loader_error_get_type()) }
    }
}

impl glib::HasParamSpec for FileLoaderError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for FileLoaderError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for FileLoaderError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FileLoaderError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<FileLoaderError> for glib::Value {
    #[inline]
    fn from(v: FileLoaderError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceFileSaverError")]
pub enum FileSaverError {
    #[doc(alias = "GTK_SOURCE_FILE_SAVER_ERROR_INVALID_CHARS")]
    InvalidChars,
    #[doc(alias = "GTK_SOURCE_FILE_SAVER_ERROR_EXTERNALLY_MODIFIED")]
    ExternallyModified,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for FileSaverError {
    type GlibType = ffi::GtkSourceFileSaverError;

    #[inline]
    fn into_glib(self) -> ffi::GtkSourceFileSaverError {
        match self {
            Self::InvalidChars => ffi::GTK_SOURCE_FILE_SAVER_ERROR_INVALID_CHARS,
            Self::ExternallyModified => ffi::GTK_SOURCE_FILE_SAVER_ERROR_EXTERNALLY_MODIFIED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceFileSaverError> for FileSaverError {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSourceFileSaverError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SOURCE_FILE_SAVER_ERROR_INVALID_CHARS => Self::InvalidChars,
            ffi::GTK_SOURCE_FILE_SAVER_ERROR_EXTERNALLY_MODIFIED => Self::ExternallyModified,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for FileSaverError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gtk_source_file_saver_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

impl StaticType for FileSaverError {
    #[inline]
    #[doc(alias = "gtk_source_file_saver_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_source_file_saver_error_get_type()) }
    }
}

impl glib::HasParamSpec for FileSaverError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for FileSaverError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for FileSaverError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FileSaverError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<FileSaverError> for glib::Value {
    #[inline]
    fn from(v: FileSaverError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceGutterRendererAlignmentMode")]
pub enum GutterRendererAlignmentMode {
    #[doc(alias = "GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_CELL")]
    Cell,
    #[doc(alias = "GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_FIRST")]
    First,
    #[doc(alias = "GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_LAST")]
    Last,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GutterRendererAlignmentMode {
    type GlibType = ffi::GtkSourceGutterRendererAlignmentMode;

    #[inline]
    fn into_glib(self) -> ffi::GtkSourceGutterRendererAlignmentMode {
        match self {
            Self::Cell => ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_CELL,
            Self::First => ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_FIRST,
            Self::Last => ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_LAST,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceGutterRendererAlignmentMode> for GutterRendererAlignmentMode {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSourceGutterRendererAlignmentMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_CELL => Self::Cell,
            ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_FIRST => Self::First,
            ffi::GTK_SOURCE_GUTTER_RENDERER_ALIGNMENT_MODE_LAST => Self::Last,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for GutterRendererAlignmentMode {
    #[inline]
    #[doc(alias = "gtk_source_gutter_renderer_alignment_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_source_gutter_renderer_alignment_mode_get_type()) }
    }
}

impl glib::HasParamSpec for GutterRendererAlignmentMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for GutterRendererAlignmentMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GutterRendererAlignmentMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for GutterRendererAlignmentMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<GutterRendererAlignmentMode> for glib::Value {
    #[inline]
    fn from(v: GutterRendererAlignmentMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceNewlineType")]
pub enum NewlineType {
    #[doc(alias = "GTK_SOURCE_NEWLINE_TYPE_LF")]
    Lf,
    #[doc(alias = "GTK_SOURCE_NEWLINE_TYPE_CR")]
    Cr,
    #[doc(alias = "GTK_SOURCE_NEWLINE_TYPE_CR_LF")]
    CrLf,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for NewlineType {
    type GlibType = ffi::GtkSourceNewlineType;

    #[inline]
    fn into_glib(self) -> ffi::GtkSourceNewlineType {
        match self {
            Self::Lf => ffi::GTK_SOURCE_NEWLINE_TYPE_LF,
            Self::Cr => ffi::GTK_SOURCE_NEWLINE_TYPE_CR,
            Self::CrLf => ffi::GTK_SOURCE_NEWLINE_TYPE_CR_LF,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceNewlineType> for NewlineType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSourceNewlineType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SOURCE_NEWLINE_TYPE_LF => Self::Lf,
            ffi::GTK_SOURCE_NEWLINE_TYPE_CR => Self::Cr,
            ffi::GTK_SOURCE_NEWLINE_TYPE_CR_LF => Self::CrLf,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for NewlineType {
    #[inline]
    #[doc(alias = "gtk_source_newline_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_source_newline_type_get_type()) }
    }
}

impl glib::HasParamSpec for NewlineType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for NewlineType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for NewlineType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for NewlineType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<NewlineType> for glib::Value {
    #[inline]
    fn from(v: NewlineType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceSmartHomeEndType")]
pub enum SmartHomeEndType {
    #[doc(alias = "GTK_SOURCE_SMART_HOME_END_DISABLED")]
    Disabled,
    #[doc(alias = "GTK_SOURCE_SMART_HOME_END_BEFORE")]
    Before,
    #[doc(alias = "GTK_SOURCE_SMART_HOME_END_AFTER")]
    After,
    #[doc(alias = "GTK_SOURCE_SMART_HOME_END_ALWAYS")]
    Always,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SmartHomeEndType {
    type GlibType = ffi::GtkSourceSmartHomeEndType;

    #[inline]
    fn into_glib(self) -> ffi::GtkSourceSmartHomeEndType {
        match self {
            Self::Disabled => ffi::GTK_SOURCE_SMART_HOME_END_DISABLED,
            Self::Before => ffi::GTK_SOURCE_SMART_HOME_END_BEFORE,
            Self::After => ffi::GTK_SOURCE_SMART_HOME_END_AFTER,
            Self::Always => ffi::GTK_SOURCE_SMART_HOME_END_ALWAYS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceSmartHomeEndType> for SmartHomeEndType {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSourceSmartHomeEndType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SOURCE_SMART_HOME_END_DISABLED => Self::Disabled,
            ffi::GTK_SOURCE_SMART_HOME_END_BEFORE => Self::Before,
            ffi::GTK_SOURCE_SMART_HOME_END_AFTER => Self::After,
            ffi::GTK_SOURCE_SMART_HOME_END_ALWAYS => Self::Always,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SmartHomeEndType {
    #[inline]
    #[doc(alias = "gtk_source_smart_home_end_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_source_smart_home_end_type_get_type()) }
    }
}

impl glib::HasParamSpec for SmartHomeEndType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SmartHomeEndType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SmartHomeEndType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SmartHomeEndType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SmartHomeEndType> for glib::Value {
    #[inline]
    fn from(v: SmartHomeEndType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GtkSourceViewGutterPosition")]
pub enum ViewGutterPosition {
    #[doc(alias = "GTK_SOURCE_VIEW_GUTTER_POSITION_LINES")]
    Lines,
    #[doc(alias = "GTK_SOURCE_VIEW_GUTTER_POSITION_MARKS")]
    Marks,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ViewGutterPosition {
    type GlibType = ffi::GtkSourceViewGutterPosition;

    #[inline]
    fn into_glib(self) -> ffi::GtkSourceViewGutterPosition {
        match self {
            Self::Lines => ffi::GTK_SOURCE_VIEW_GUTTER_POSITION_LINES,
            Self::Marks => ffi::GTK_SOURCE_VIEW_GUTTER_POSITION_MARKS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GtkSourceViewGutterPosition> for ViewGutterPosition {
    #[inline]
    unsafe fn from_glib(value: ffi::GtkSourceViewGutterPosition) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GTK_SOURCE_VIEW_GUTTER_POSITION_LINES => Self::Lines,
            ffi::GTK_SOURCE_VIEW_GUTTER_POSITION_MARKS => Self::Marks,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ViewGutterPosition {
    #[inline]
    #[doc(alias = "gtk_source_view_gutter_position_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gtk_source_view_gutter_position_get_type()) }
    }
}

impl glib::HasParamSpec for ViewGutterPosition {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ViewGutterPosition {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ViewGutterPosition {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ViewGutterPosition {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ViewGutterPosition> for glib::Value {
    #[inline]
    fn from(v: ViewGutterPosition) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
